<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>gradle深入理解笔记 | kutec.cn-分享技术，分享成长</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="gradle深入理解笔记Gradle 工程配置说明：
每个 Project 都须设置一个 build.gradle 文件。 multi-projects build，需在根目录下放一个 build.gradle 和 settings.gradle。 
一个 Project 是由若干 tasks 来组成的，可通过gradle xxx 来执行具体任务
具体工作和不同的插件有关系。插件定义很多相关工作的">
<meta property="og:type" content="article">
<meta property="og:title" content="gradle深入理解笔记">
<meta property="og:url" content="http://wangrenxing.github.io/2016/05/21/gradle深入理解笔记/index.html">
<meta property="og:site_name" content="kutec.cn-分享技术，分享成长">
<meta property="og:description" content="gradle深入理解笔记Gradle 工程配置说明：
每个 Project 都须设置一个 build.gradle 文件。 multi-projects build，需在根目录下放一个 build.gradle 和 settings.gradle。 
一个 Project 是由若干 tasks 来组成的，可通过gradle xxx 来执行具体任务
具体工作和不同的插件有关系。插件定义很多相关工作的">
<meta property="og:updated_time" content="2016-05-21T09:15:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gradle深入理解笔记">
<meta name="twitter:description" content="gradle深入理解笔记Gradle 工程配置说明：
每个 Project 都须设置一个 build.gradle 文件。 multi-projects build，需在根目录下放一个 build.gradle 和 settings.gradle。 
一个 Project 是由若干 tasks 来组成的，可通过gradle xxx 来执行具体任务
具体工作和不同的插件有关系。插件定义很多相关工作的">
  
    <link rel="alternative" href="/atom.xml" title="kutec.cn-分享技术，分享成长" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/assets/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">wangrenxing</a></h1>
		</hgroup>

		
		<p class="header-subtitle">愿意改变，什么时候开始都不晚！</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/tags/随笔/">随笔</a></li>
				        
							<li><a href="/bookmarks">书签</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/wangrenxing" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/gradle/" style="font-size: 10px;">gradle</a> <a href="/tags/ios/" style="font-size: 20px;">ios</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="#">虚位以待</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">码农界平凡且爱折腾的一枚童鞋，徘徊在 C/C++/Java 的世界，献身于移动端！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">wangrenxing</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/assets/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">wangrenxing</h1>
			</hgroup>
			
			<p class="header-subtitle">愿意改变，什么时候开始都不晚！</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔/">随笔</a></li>
		        
					<li><a href="/bookmarks">书签</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/wangrenxing" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-gradle深入理解笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/21/gradle深入理解笔记/" class="article-date">
  	<time datetime="2016-05-21T09:14:52.000Z" itemprop="datePublished">2016-05-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      gradle深入理解笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gradle/">gradle</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="gradle深入理解笔记"><a href="#gradle深入理解笔记" class="headerlink" title="gradle深入理解笔记"></a>gradle深入理解笔记</h1><h3 id="Gradle-工程配置说明："><a href="#Gradle-工程配置说明：" class="headerlink" title="Gradle 工程配置说明："></a>Gradle 工程配置说明：</h3><ol>
<li>每个 Project 都须设置一个 build.gradle 文件。 multi-projects build，需在根目录下放一个 build.gradle 和 settings.gradle。 </li>
<li>一个 Project 是由若干 tasks 来组成的，可通过gradle xxx 来执行具体任务</li>
<li>具体工作和不同的插件有关系。插件定义很多相关工作的task。</li>
</ol>
<h3 id="Gradle-工作三个阶段："><a href="#Gradle-工作三个阶段：" class="headerlink" title="Gradle 工作三个阶段："></a>Gradle 工作三个阶段：</h3><ol>
<li>初始化阶段。multi-project build 是执行 settings.gradle。</li>
<li>配置阶段。Configration 阶段的目标是解析每个 project 中的 build.gradle，确定整个build的project以及内部task的依赖关系。在这两个阶段之间，可通过api来加一些定制化的 Hook。  </li>
<li>执行任务。根据task依赖关系，依次执行任务，其后还添加 Hook。</li>
</ol>
<h3 id="Gradle-编程模型及重要文档："><a href="#Gradle-编程模型及重要文档：" class="headerlink" title="Gradle 编程模型及重要文档："></a>Gradle 编程模型及<a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">重要文档</a>：</h3><ol>
<li>Gradle 对象：执行任务时 gradle 会从默认的配置脚本中构造出一个 Gradle 对象。在整个执行过程中，只有这么一个对象。</li>
<li>Project 对象：每一个 build.gradle 会转换成一个 Project，可直接使用其属性。 对象。<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="external">查看属性函数</a></li>
<li>Settings 对象：显然，每一个 settings.gradle 都会转换成一个 Settings 对象。</li>
<li>可直接在build.gradle中直接使用gradle、project、settings对象。</li>
</ol>
<p>Project 对象对应的是 Build Script。具体工作：</p>
<ol>
<li>加载插件。Project 包含若干 Tasks。对应具体的工程，为其加载所需要的插件。通过 apply 函数，不同参数名来调用，apply from: ‘插件名’，apply from: ‘gradle文件路径名’</li>
<li>不同插件有不同的配置。需要在 Project 中配置好，插件就知道从哪里读取源文件等。</li>
<li>设置属性。多个 gradle 文件中共用参数，可通过全局唯一gradle对象 设置 ext 属性来实现。Gradle 的 extra property 设置需在第一次定义该属性的时候需要通过 ext 前缀来标示它是一个额外的属性。Project 和 Gradle 对象都可以设置 ext 属性。</li>
</ol>
<p>例子：  </p>
<pre><code>[settings.gradle]
def initMinshengGradleEnvironment(){
    //属性值从 local.properites 中读取  
    Properties properties = new Properties()
    File propertyFile = new File(rootDir.getAbsolutePath() + &quot;/local.properties&quot;)
    properties.load(propertyFile.newDataInputStream())
    //gradle 就是 Gradle 对象。它默认是 Settings 和 Project 的成员变量。
    // 可直接获取 ext 前缀，表明操作的是外置属性。
    // api 是一个新的属性名。
    // 第一次定义或者设置它的时候需要 ext 前缀  
    gradle.ext.api = properties.getProperty(&apos;sdk.api&apos;)
    println gradle.api  //再次存取 api 的时候，就不需要 ext 前缀了  
}

[utils.gradle]
// utils.gradle 中定义了一个获取 AndroidManifests.xml versionName 的函数  
def  getVersionNameAdvanced(){
   // 下面这行代码中的 project 是谁？ project 就是加载 utils.gradle 的 project。
   def xmlFile = project.file(&quot;AndroidManifest.xml&quot;) 
   def rootManifest = new XmlSlurper().parse(xmlFile)
   return rootManifest[&apos;@android:versionName&apos;]   
}
// 现在，想把这个 API 输出到各个 Project。
// 由于这个 utils.gradle 会被每一个 Project Apply，
// 所以我可以把 getVersionNameAdvanced 定义成一个 closure，
// 然后赋值到一个外部属性  
// 下面的 ext 是谁的 ext？  是 Project 对应的 ext 。
ext { //此段花括号中代码是闭包  
    // 除了 ext.xxx=value 这种定义方法外，还可以使用 ext{}这种书写方法。
    // ext{}不是 ext(Closure)对应的函数调用。但是 ext{}中的{}确实是闭包。  
    getVersionNameAdvanced = this.&amp;getVersionNameAdvanced
}
</code></pre><h4 id="答疑："><a href="#答疑：" class="headerlink" title="答疑："></a>答疑：</h4><p>Project 和 utils.gradle 对于的 Script 的对象的关系是：<br>当一个 Project apply 一个 gradle 文件的时候，这个 gradle 文件会转换成一个 Script 对象。<br>Script 中有一个 delegate 对象，这个 delegate 默认是加载（即调用 apply）它的 Project 对象。在 apply 函数中，有一个 from 参数，还有一个 to 参数。通过 to 参数，你可以把 delegate 对象指定为别的东西。<br>当你在 Script 中操作一些不是 Script 自己定义的变量，或者函数时候，gradle 会到 Script 的 delegate 对象去找，看看有没有定义这些变量或函数。  </p>
<p><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">Task</a> 介绍：<br>Task 是 Gradle 中的一种数据类型，代表一些要执行的工作。每个 Task 都需要和一个 Project 关联。</p>
<pre><code>[build.gradle]
//Task 是和 Project 关联的，所以，我们要利用 Project 的 task 函数来创建一个 Task
task myTask  &lt;==myTask 是新建 Task 的名字  
task myTask { configure closure }
task myType &lt;&lt; { task action }  &lt;==注意，&lt;&lt;符号 是 doLast 的缩写  
task myTask(type: SomeType)
task myTask(type: SomeType) { configure closure }
</code></pre><p>一个 Task 包含若干 Action。所以，Task 有 doFirst 和 doLast 两个函数，用于添加需要最先执行的 Action 和需要和需要最后执行的 Action。Action 就是一个闭包。<br>Task 创建的时候可以指定 Type，通过 type:名字表达。就是告诉 Gradle，这个新建的 Task 对象会从哪个基类 Task 派生。Copy 是 Gradle 中的一个类。task myTask(type:Copy)，创建的 Task 就是一个 Copy Task。<br>task myTask &lt;&lt; {xxx}，创建了一个 Task 对象，同时把 closure 做为一个 action 加到这个 Task 的 action 队列中，并且告诉它“最后才执行这个 closure”（注意，&lt;&lt;符号是 doLast 的代表）。</p>
<p>例子</p>
<pre><code>[utils.gradle]
import groovy.util.XmlSlurper  //解析 XML 时候要引入这个 groovy 的 package
// 拷贝文件函数，用于将最后的生成物拷贝到指定的目录  
def copyFile(String srcFile,dstFile){}
// 删除指定目录中的文件  
def rmFile(String targetFile){}
// clean 的时候清理  
def cleanOutput(boolean bJar = true){}
// copyOutput 内部会调用 copyFile 完成一次 build 的产出物拷贝  
def copyOutput(boolean bJar = true){}
def getVersionNameAdvanced(){
   def xmlFile = project.file(&quot;AndroidManifest.xml&quot;)
   def rootManifest = new XmlSlurper().parse(xmlFile)
   return rootManifest[&apos;@android:versionName&apos;]   
}
// 对于 android library 编译，我会 disable 所有的 debug 编译任务  
def disableDebugBuild(){
  //project.tasks 包含了所有的 tasks，
  // findAll 是寻找那些名字中带 debug 的 Task。
  //返回值保存到 targetTasks 容器中  
  def targetTasks = project.tasks.findAll{ task -&gt;
      task.name.contains(&quot;Debug&quot;)
  }
  // 对满足条件的 task，设置它为 disable。如此这般，这个 Task 就不会被执行  
  targetTasks.each {
     println &quot;disable debug task  : ${it.name}&quot;
     it.setEnabled false
  }
}
// 将函数设置为 extra 属性中去
// 加载 utils.gradle 的 Project 就能调用此文件中定义的函数
ext{
    copyFile = this.&amp;copyFile
    rmFile = this.&amp;rmFile
    cleanOutput = this.&amp;cleanOutput
    copyOutput = this.&amp;copyOutput
    getVersionNameAdvanced = this.&amp;getVersionNameAdvanced
    disableDebugBuild = this.&amp;disableDebugBuild
}

[settings.gradle]
/** 编译环境初始化函数  
 * 1  解析一个名为 local.properties 的文件，读取 Android SDK 和 NDK 的路径  
 * 2  获取最终产出物目录的路径。编译完的 apk 或者 jar 包将拷贝到这个最终产出物目录中  
 * 3 获取 Android SDK 指定编译的版本  
 **/
def initMinshengGradleEnvironment(){
    println &quot;initialize Minsheng Gradle Environment .....&quot;
    Properties properties = new Properties()
    File propertyFile = new File(rootDir.getAbsolutePath() + &quot;/local.properties&quot;)
    properties.load(propertyFile.newDataInputStream())
    /** 根据 Project、Gradle 生命周期，settings 对象的创建位于具体 Project 创建之前。
      * Gradle 对象已经创建好了。
      * local.properties 的信息读出来后，通过extra 属性的方式设置到 gradle 对象中
      * 具体 Project 在执行时，直接从 gradle 对象中得到这些属性了！
      **/
    gradle.ext.api = properties.getProperty(&apos;sdk.api&apos;)
    gradle.ext.sdkDir = properties.getProperty(&apos;sdk.dir&apos;)
    gradle.ext.ndkDir = properties.getProperty(&apos;ndk.dir&apos;)
    gradle.ext.localDir = properties.getProperty(&apos;local.dir&apos;)
    gradle.ext.debugKeystore = properties.getProperty(&apos;debug.keystore&apos;)
    gradle.ext.releaseKeystore = properties.getProperty(&apos;release.keystore&apos;)
     ......
    println &quot;initialize Minsheng Gradle Environment completes...&quot;
}
//初始化  
initMinshengGradleEnvironment()
//添加子 Project 信息  
include &apos;CPosSystemSdk&apos; , &apos;CPosDeviceSdk&apos; , &apos;CPosSdkDemo&apos;,&apos;CPosDeviceServerApk&apos;, &apos;CPosSystemSdkWizarPosImpl&apos;

// 敏感信息隐藏，可单独建立文件，不做版本控制
[local.properties]
local.dir=/home/innost/workspace/minsheng-flat-dir/
sdk.dir=/home/innost/workspace/android-aosp-sdk/
ndk.dir=/home/innost/workspace/android-aosp-ndk/

debug.keystore=/home/innost/workspace/tools/mykeystore.jks
sdk.api=android-19

//clean 是一个 Task 的名字，是插件引入的。  
//dependsOn 是一个函数
//clean 任务依赖 cposCleanTask 任务。
//gradle clean 执行 clean Task 时，cposCleanTask 也会执行  
clean.dependsOn &apos;cposCleanTask&apos;
task cposCleanTask() &lt;&lt; {
    //cleanOutput 是 utils.gradle 中通过 extra 属性设置的 Closure
    cleanOutput(true)
}

//tasks 代表一个 Projects 中的所有 Task，是一个容器。
// getByName 表示找到指定名称的任务。
tasks.getByName(&quot;assemble&quot;) {
    it.doLast{
        println &quot;$project.name: After assemble, jar libs are copied to local repository&quot;
        copyOutput(true)
     }
}
// 当 Project 创建完所有任务的有向图后，通过 afterEvaluate 函数设置一个回调 Closure。
// 在这个回调 Closure 里， disable 了所有 Debug 的 Task
project.afterEvaluate{
    disableDebugBuild()
}

// 创建一个 Task，类型是 Exec，表明它会执行一个命令
// tasks.withType(JavaCompile) 设置的依赖关系
task buildNative(type: Exec, description: &apos;Compile JNI source via NDK&apos;) {
        if( project.gradle.ndkDir == null )
           println &quot;CANNOT Build NDK&quot;
        else{
            commandLine &quot;/${project.gradle.ndkDir}/ndk-build&quot;,
                &apos;-C&apos;, file(&apos;jni&apos;).absolutePath,
                &apos;-j&apos;, Runtime.runtime.availableProcessors(),
                &apos;all&apos;, &apos;NDK_DEBUG=0&apos;
        }
  }
 tasks.withType(JavaCompile) {
        compileTask -&gt; compileTask.dependsOn buildNative
  }



[build.gradle]
apply plugin: &apos;com.android.application&apos;
apply from: rootProject.getRootDir().getAbsolutePath() + &quot;/utils.gradle&quot;
//buildscript 设置 android app 插件的位置
buildscript {
    repositories { jcenter() }
    dependencies { classpath &apos;com.android.tools.build:gradle:1.2.3&apos; }
}
//android ScriptBlock
android {
    compileSdkVersion gradle.api
    buildToolsVersion &quot;22.0.1&quot;
   sourceSets{ //源码设置 SB
        main{
            manifest.srcFile &apos;AndroidManifest.xml&apos;
            jni.srcDirs = []
            jniLibs.srcDir &apos;libs&apos;
            aidl.srcDirs=[&apos;src&apos;]
            java.srcDirs=[&apos;src&apos;]
            res.srcDirs=[&apos;res&apos;]
            assets.srcDirs = [&apos;assets&apos;] //多了一个 assets 目录  

        }
    }
    signingConfigs {//签名设置  
        debug {  //debug 对应的 SB。注意  
            if(project.gradle.debugKeystore != null){
                storeFile file(&quot;file://${project.gradle.debugKeystore}&quot;)
                storePassword &quot;android&quot;
                keyAlias &quot;androiddebugkey&quot;
                keyPassword &quot;android&quot;
            }
        }
    }
    /*
    buildTypes ScriptBlock.
    buildTypes 和上面的 signingConfigs，在 build.gradle 中通过{}配置它的时候，
    背后所代表对象是 NamedDomainObjectContainer&lt;BuildType&gt; 和  
    NamedDomainObjectContainer&lt;SigningConfig&gt;
    NamedDomainObjectContainer&lt;BuildType/或者 SigningConfig&gt;是一种容器，  
    容器的元素是 BuildType 或者 SigningConfig。
    在 debug{}要填充 BuildType 或者 SigningConfig 所包的元素，
    比如 storePassword 就是 SigningConfig 类的成员。
    proguardFile 等是 BuildType 的成员。  
    */
    signingConfig{//这是一个 NamedDomainObjectContainer&lt;SigningConfig&gt;
       test1{//新建一个名为 test1 的 SigningConfig 元素，然后添加到容器里  
         //在这个花括号中设置 SigningConfig 的成员变量的值  
       }
      test2{//新建一个名为 test2 的 SigningConfig 元素，然后添加到容器里  
         //在这个花括号中设置 SigningConfig 的成员变量的值  
      }
    }
    //在 buildTypes 中，Android 默认为这几个 NamedDomainObjectContainer 添加了  
    debug 和 release 对应的对象。
    //如果我们再添加别的名字的东西，那么 gradle assemble 的时候  
    //也会编译这个名字的 apk 出来。

    buildTypes{
        debug{ //修改 debug 的 signingConfig 为 signingConfig.debug 配置  
            signingConfig signingConfigs.debug
        }
        demo{ //demo 版需要混淆
            proguardFile &apos;proguard-project.txt&apos;
            signingConfig signingConfigs.debug
        }
       //release 版没有设置，所以默认没有签名，没有混淆  
    }
   //来看如何动态生成 runtime_config 文件  
   def runtime_config_file = &apos;assets/runtime_config&apos;
   /*
   我们在 gradle 解析完整个任务之后，找到对应的 Task，然后在里边添加一个 doFirst Action
   这样能确保编译开始的时候，我们就把 runtime_config 文件准备好了。
   注意，必须在 afterEvaluate 里边才能做，否则 gradle 没有建立完任务有向图，你是找不到什么 preDebugBuild 之类的任务的
   */
    project.afterEvaluate{
      //找到 preDebugBuild 任务，然后添加一个 Action  
      tasks.getByName(&quot;preDebugBuild&quot;){
            it.doFirst{
                println &quot;generate debug configuration for ${project.name}&quot;
                def configFile = new File(runtime_config_file)
                configFile.withOutputStream{os-&gt;
                    os &lt;&lt; I am Debug\n&apos;  //往配置文件里写 I am Debug
                 }
            }
        }
       //找到 preReleaseBuild 任务  
        tasks.getByName(&quot;preReleaseBuild&quot;){
            it.doFirst{
                println &quot;generate release configuration for ${project.name}&quot;
                def configFile = new File(runtime_config_file)
                configFile.withOutputStream{os-&gt;
                    os &lt;&lt; I am release\n&apos;
                }
            }
        }
       //找到 preDemoBuild，此任务是在 buildType 里添加了一个 demo 的元素  
      //所以 Android APP 插件自动为我们生成的  
        tasks.getByName(&quot;preDemoBuild&quot;){
            it.doFirst{
                println &quot;generate offlinedemo configuration for ${project.name}&quot;
                def configFile = new File(runtime_config_file)
                configFile.withOutputStream{os-&gt;
                    os &lt;&lt; I am Demo\n&apos;
                }
            }
        }
    }
}
</code></pre><p><a href="http://wiki.jikexueyuan.com/project/deep-android-gradle/" target="_blank" rel="external">参考一</a><br><a href="https://segmentfault.com/a/1190000004229002" target="_blank" rel="external">参考二</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/30/cocoapods依赖管理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          cocoapods依赖管理
        
      </div>
    </a>
  
  
    <a href="/2016/05/21/apk编译打包流程笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">apk编译打包流程笔记</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="gradle深入理解笔记" data-title="gradle深入理解笔记" data-url="http://wangrenxing.github.io/2016/05/21/gradle深入理解笔记/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"wangrenxing"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 wangrenxing
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>